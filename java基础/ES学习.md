# ES学习

es与传统数据库对比：

* Relational DB -> Databases -> Tables -> Rows -> Columns
* Elasticsearch -> Indices -> Types -> Documents -> Fields 

# 数据是如何在Elasticsearch中被索引的 

**映射(mapping)机制**用于进行字段类型确认，将每个字段匹配为一种确定的数据类型
( string , number , booleans , date 等)。
**分析(analysis)机制**用于进行全文文本(Full Text)的分词，以建立供搜索用的反向索引。



# 查询和过滤

**查询**即是之前提到的query查询，它**（查询）默认会计算每个返回文档的得分，然后根据得分排序**。

**过滤（filter）只会筛选出符合的文档，并不计算得分，且它可以缓存文档。**所以，单从性能考虑，过滤比查询更快。

换句话说，过滤适合在大范围筛选数据，而查询则适合精确匹配数据。一般应用时，**应先使用过滤操作过滤数据，然后使用查询匹配数据。**



# 查询中文无返回结果

**elasticsearch 里默认的IK分词器是会将每一个中文都进行了分词的切割，所以你直接想查一整个词，或者一整句话是无返回结果的**。

**matchQuery**：会将搜索词分词，再与目标查询字段进行匹配，若分词中的任意一个词与目标字段匹配上，则可查询到。

**termQuery**：不会对搜索词进行分词处理，而是作为一个整体与目标字段进行匹配，若完全匹配，则可查询到。



# 坑

1.x 2.x版本设置 no not_analyzed即可。
5.xstring分为两种类型keyword,text。如果不想分词，用keyword即可。

# 自定义分析器

分析器 是三个顺序执行的组件的结合（**字符过滤器**，**分词器**，**标记过滤器**）

**字符过滤器**：字符过滤器是让字符串在被分词前变得更加“整洁”。

**分词器**：一个分析器必须包含一个分词器。分词器将字符串分割成单独的词（terms） 或标记
（tokens）。

**标记过滤器：**分词结果的标记流会根据各自的情况，传递给特定的标记过滤器。

# 过滤操作

1. 查找匹配文档
2. 创建字节集
3. 缓存字节集

这里要注意的是QueryBuilders的termQuery方法以及matchQuery方法，这两个方法都可以进行单字段匹配的查询，但是这两个是有区别的。具体区别原理还没有学习，但是如果你的字段不是一个整体（类似cus_name）这样的就需要使用matchQuery或者是termQuery的第一个参数也就是你的字段后面加上.keyword。也就是说如果字段是一个整体那么这两个方法是一样的效果，例如：

matchQuery("name","张三")等价于termQuery("name","张三")。如果字段不是一个整体，那么这两个的效果如下：

matchQuery("cus_name","张三")等价于termQuery("cus_name.keyword","张三")。

链接：https://www.jianshu.com/p/98e864893f69



# ES分页查询

当我想要查询第10条到第20条的数据该怎么办呢？这个时候就用到分页查询了。

在ElasticSearch中实现分页查询的方式有两种，分别为**深度分页(from-size)**和**快照分页(scroll)**

1. **深度分页(from-size)**

    原理很简单，就是查询前20条数据，然后截断前10条，只返回10-20的数据。这样其实白白浪费了前10条的查询。from定义了目标数据的偏移值，size定义当前返回的事件数目。默认from为0，size为10，即所有的查询默认仅仅返回前10条数据。做过测试，越往后的分页，执行的效率越低。也就是说，**分页的偏移值越大，执行分页查询时间就会越长！**

    ES使用index.max_result_window:10000作爲保护措施 ，即默认 from + size 不能超过10000，虽然这个参数可以动态修改，也可以在配置文件配置，但是最好不要这麽做，应该改用ES游标来取得数据。

2. **快照分页(scroll)**

   相对于from和size的分页来说，使用scroll可以模拟一个传统数据的游标，记录当前读取的文档信息位置。scroll 具体分为**初始化**和**遍历**两步，初始化将所有符合搜索条件的结果缓存起来，可以想象为快照；在遍历时，从这个快照中取数据。这个分页的用法，**不是为了实时查询数据，而是为了一次性查询大量的数据**（甚至是全部的数据）。因为这个scroll相当于维护了一份当前索引段的快照信息，这个快照信息是你执行这个scroll查询时的快照。在这个查询后的任何新索引进来的数据，都不会在这个快照中查询到。但是它相对于from和size，不是查询所有数据然后剔除不要的部分，而是记录一个读取的位置，保证下一次快速继续读取。

由此也可以看出**scroll不适合支持那种实时的和用户交互的前端分页工作**，其主要用途用于从ES集群分批拉取大量结果集的情况，一般都是offline的应用场景。  比如需要将非常大的结果集拉取出来，存放到其他系统处理，或者需要做大索引的reindex等等。