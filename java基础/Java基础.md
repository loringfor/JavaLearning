# 必会关键字

**void    byte    int    long    char    short    float    double    String    StringBuffer    StringBuilder    Array    Collection    Collections    List    ArrayList    LinkedList    Vector    Set    Hash    Map    TreeMap    LinkedHashMap    ConcerrentHash    MapSet    TreeMap    HashMap    synchronized    volatile    transient    implements    extends    public    private    protected    this    super    static    final    const    run    start    thread    enmu    stack    queue    list    heap    throw    throws    try    catch    finally    break    continue    instanceof**

# 计算机基础知识数据结构

## 1. 什么是队列、栈、链表

## 2. 什么是树（平衡树,排序树,B树,B+树,R树,红黑树）、堆（大根堆、小根堆）、图（有向图、无向图、拓扑）

**红黑树：（自平衡的二叉搜索树）**

1. 每个节点不是红色就是黑色的；

2. 根节点总是黑色的；

3. 所有的叶节点都是是黑色的（红黑树的叶子节点都是空节点（NIL或者NULL））；

4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；

5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。


**应用场景：**java中的TreeSet,TreeMap，广泛用在C++的STL中。如map和set都是用红黑树实现的

## 3. 栈和队列的相同和不同之处

栈与队列的**相同点**：

- 都是线性结构。
- 插入操作都是限定在表尾进行。

- 都可以通过顺序结构和链式结构实现。

- 插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样。

- 多链栈和多链队列的管理模式可以相同。


栈与队列的**不同点**：

- 删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。

- 应用场景不同；常见栈的应用场景包括括号问题的求解，表达式的转换和求值，函数调用和递归实现，深度优先搜索遍历等；常见的队列的应用场景包括计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等。

- 顺序栈能够实现多栈空间共享，而顺序队列不能。


## 4. 栈通常采用的两种存储结构

顺序存储、链式存储

## 5. 两个栈实现队列，和两个队列实现栈

## 6. 散列冲突的几种解决方法

1. 开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）

2. 链地址法(Java HashMap就是这么做的)

3. 再哈希法

4. 建立一个公共溢出区


## 7. 为什么使用补码

a) **原码**就是符号位加上真值的绝对值, 即用**第一位表示符号**, 其余位表示值. 比如如果是8位二进制:

[+1]原 = 0000 0001

[-1]原 = 1000 0001

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]即[-127 , 127]

b) **反码**的表示方法是:**正数**的反码是其本身，**负数**的反码是在其原码的基础上, 符号位不变，其余各个位取反.

[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

c) **补码**的表示方法是:**正数**的补码就是其本身，**负数**的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.

**为何使用：**

现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:

[+1] = [00000001]原 = [00000001]反 = [00000001]补

所以不需要过多解释. 但是对于负数:

[-1] = [10000001]原 = [11111110]反 = [11111111]补

可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码:

计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

于是补码的出现, 解决了0的符号以及两个编码的问题:

1-1 = 1 + (-1) =[0000 0001]原 +[1000 0001]原 =[0000 0001]补 +[1111 1111]补 =[00000000]补=[00000000]原

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

(-1) + (-127) =[1000 0001]原 +[1111 1111]原 =[1111 1111]补 +[1000 0001]补 =[1000 0000]补

-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)

**使用补码不仅仅修复了0的符号以及存在两个编码的问题, **而且还能够多表示一个最低数.*这就是为什么**8**位二进制**,** **使用原码或反码表示的范围为**[-127, +127],** **而使用补码表示的范围为**[-128, 127].**

因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值。

## 8. C语言中的内存泄漏

有些程序并不需要管理它们的动态内存的使用。当需要内存时，它们简单地通过分配来获得，从来不用担心如何释放它。这类程序包括编译器和其他一些运行一段固定的（或有限的）时间然后终止的程序。当这种类型的程序终止时，所有内存会被自动回收。细心查验每块内存是否需要回收纯属浪费时间，因为它们不会再被使用。

其他程序的生存时间要长一点。有些工具如日历管理器、邮件工具以及操作系统本身经常需要数日及至数周连续运行，并需要管理动态内存的分配和回收。由于C语言通常并不使用垃圾回收器（自动确认并回收不再使用的内存块），这些C程序在使用malloc()和free()时不得不非常慎重。堆经常会出现两种类型的问题：

1. **释放或改写仍在使用的内存(称为：“内存损坏”)。**

2. **未释放不再使用的内存(称为：“内存泄露”)。**

这是最难被调试发现的问题之一。如果每次已分配的内存块不再使用而程序并不释放它们，进程就会一边分配越来越多的内存，一边却并不释放不再使用的那部分内存。

**避免内存泄露**

每当调用malloc分配内存时，注意在以后要调用相应的free来释放它。

如果不知道如何调用free与先前的malloc相对应，那么很可能已经造成了内存泄露！

一种简单的方法就是在可能的时候使用malloc()来分配动态内存，以避免上述情况。当离开调用malloc的函数时，它所分配的内存会被自动释放。

显然，这并不适用于那些比创建它们的函数生命期更长的结构。但如果对象的生命期在该函数结束前便已经终止，这种建立在堆栈上的动态内存分配是一种开销很小的选择。有些人不提倡使用malloc，因为它并不是以后总可移植的方法。如果处理器在硬件上不支持堆栈，malloc ()就很难高效地实现。

我们使用“内存泄露”这个词是因为一种稀有的资源正在被一个进程榨干。内存泄露的主要可见症状就是罪魁进程的速度很减慢。原因是体积大的进程更有可能被系统换出，让别的进程运行，而且大的进程在换进换出时花费的时间也更多。即使泄露的内存本省并不被引用，但它仍用可能存在于页面中（内容自然是垃圾），这样就增加了进程的工作页数量，降低了性能。另外需要注意的一点是，内存泄露往往比忘记释放的的数据结构要大，因为malloc()所分配的内存通常会圆整为下一个大于申请数量的2的整数次方（如申请212B,会圆整为256B）。在资源有限的情况下，即使引起内存泄露的进程并不运行，整个系统运行速度也会被拖慢。从理论上说，进程的大小有一个上限值，这在不同的操作系统中各不相同。在当前的SunOS版本中，进程的最大地址空间可以多达4GB。事实上，在进程所泄露的内存远未达到这个数量时，磁盘的交换区早已消耗殆尽。

**如何检测内存泄露**

观察内存泄露是一个两步骤的过程。首先，使用swap命令观察还有多少可用的交换空间：

/usr/sbin/swap -s

total:17228K bytes allocated + 5396K reserved=22626K used，29548K available.

在一两分钟内键入该命令三到四次，看看可用的交换区是否在减少。还可以使用其他一些/usr/bin/*stat工具如netstat、vmstat等。如发现波段有内存被分配且从不释放，一个可能的解释就是有个进程出现了内存泄露。

# 算法

## 1. 排序都有哪几种方法？

冒泡排序、简单选择排序、直接插入排序、希尔排序、堆排序、归并排序、快速排序

## 2. 会写常用的排序算法，如快排，归并等。

## 3. 各种排序算法的时间复杂度和稳定性，重点快排。

| 排序方法 | 平均时间 | 最好情况 | 最差情形 | 额外空间  | 稳定度 |
| :------: | :-------------: | :------: | :------: | :-----------: | :----: |
| 冒泡 | O($n^2$) | O(n) | O($n^2$) | O(1)  | 稳定  |
| 选择 | O($n^2$) | O($n^2$) | O($n^2$) | O(1)  | 不稳定 |
| 插入 | O($n^2$) | O(n) | O($n^2$) | O(1)  | 稳定  |
| Shell | O($nlogn$)~ O($n^2$) | O($n^{1.3}$​) | O($n^2$) | O(1)  | 不稳定 |
| 堆  | O($nlogn$) | O($nlogn$) | O($nlogn$) | O(1)  | 不稳定 |
| 归并 | O($nlogn$) | O($nlogn$) | O($nlogn$) | O(n)  | 稳定  |
| 快速 | O($nlogn$) | O($nlogn$) | O($n^2$) | O($logn$)~O(n) | 不稳定 |

**一些结论：**

① 基本有序的情况下，**插入排序**效率最高 

② **冒泡排序**，**插入排序**和**快速排序**的排序趟数与序列的初始状态有关

③ **堆排序**和**选择排序**的排序次数与初始状态无关，即最好情况和最坏情况都一样



## 4. 单链表的遍历和逆序，部分链表的反转

## 5. 深度优先搜索和广度优先搜索

## 6. 前序中序后序非递归遍历，层次遍历（要求5分钟内准确写出来）

## 7. 生成树算法（动态规划/贪心）

## 8. 回溯法，递归的运用

## 9. 最小生成树

## 10. 常见Hash算法，哈希的原理和代价

- MD4、MD5、SHA-1

- 以空间换时间的算法


## 11. 全排列、贪心算法、KMP算法、hash算法、动态规划、最大流、布隆过滤器

## 12. 一致性Hash算法

# 操作系统

## 1. 虚拟内存管理

产生原因：实际内存不够

优点：虚拟内存可以大于物理内存，一般为物理内存的1.5倍到3倍，从而可以运行比物理内存大的程序，进而使得更多的程序可以同时执行，提高了多道程序的程度，增加了CPU的使用率，并且使得进程之间的独立性得到了更好的体现。

## 2. 换页算法

页面置换：在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断(page fault)。当发生缺页中断时操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。 

**OPT：最佳替换算法（optional replacement）**。替换下次访问距当前*时间*最长的页。opt算法需要知道操作系统将来的事件，显然不可能实现，只作为一种衡量其他算法的标准。

**LRU:最近最少使用(Least Recently Used)**。替换上次使用距离当前最远的页。根据局部性原理：替换最近最不可能访问到的页。性能最接近OPT，但难以实现。可以维护一个关于访问页的栈或者给每个页添加最后访问的时间标签，但开销都很大。

**FIFO:先进先出(First In First Out)**。将页面看做一个循环缓冲区，按循环方式替换。这是实现最为简单的算法，隐含的逻辑是替换驻留在内存时间最长的页。但由于一部分程序或数据在整个程序的生命周期中使用频率很高，所以会导致反复的换入换出。

**Clock：时钟替换算法（Clock）**。给每个页帧关联一个使用位。当该页第一次装入内存或者被重新访问到时，将使用位置为1。每次需要替换时，查找使用位被置为0的第一个帧进行替换。在扫描过程中，如果碰到使用位为1的帧，将使用位置为0，在继续扫描。如果所谓帧的使用位都为0，则替换第一个帧。

## 3. 进程、线程间通信

**进程与线程的区别是什么？**

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。另外，也正是因为共享资源，所以线程中执行时一般都要进行同步和互斥。总的来说，**进程和线程的主要差别在于它们是不同的操作系统资源管理方式**。

**进程间的几种通信方式说一下？**

- **管道（pipe）**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有**血缘关系**的进程间使用。进程的血缘关系通常指父子进程关系。管道分为**pipe（无名管道）**和**name pipe（命名管道）**两种，有名管道也是半双工的通信方式，但是它允许**无亲缘关系**进程间通信。
- **信号（signal）**：信号是在**软件层次上对中断机制的一种模拟**，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。
- **消息队列（message queue）**：消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。**具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息**。
- **共享内存（shared memory）**：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，**不同进程可以及时看到对方进程中对共享内存中数据得更新**。这种方式需要依靠某种同步操作，如**互斥锁**和**信号量**等。
- **信号量（semophore）**：**主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段**。信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种*锁机制*，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- **套接字（socket）**：socket，即套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。

**线程间的几种通信方式知道不？**

1. **锁机制**

- 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。

- 读写锁：允许多个线程同时读共享数据，而对写操作互斥。

- 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。


2. **信号量机制：**包括无名线程信号量与有名线程信号量

3. **信号机制：**类似于进程间的信号处理。

* 线程间通信的**主要目的是用于线程同步**，所以线程没有象进程通信中用于数据交换的通信机制。

## 4. 死锁的四个必要条件，避免方法；银行家算法、哲学家进餐

产生死锁的**原因**主要是：

（1） 因为系统资源不足。

（2） 进程运行推进的顺序不合适。

（3） 资源分配不当等。

如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。

产生死锁的四个**必要条件**：

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 

**死锁的解除与预防：**

理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

## 5. Linux的一些基本命令（内存查看，进程查看之类的），还有ls、tail、chmod、find等

查看cpu的型号命令：dmesg |grep -i xeon

查看内存的命令：free –m

查看硬盘大小：df –h

用top命令也可以查看到cpu和内存的使用率 在输入top命令之后直接按"1" 就能很清楚的查看到cpu和内存的使用情况。

查看进程：ps –A，查看所有；ps aux，详情；

查看端口占用：netstat，lsof

linux中命令cat、more、less均可用来查看文件内容，主要区别有:<https://www.jianshu.com/p/d5c44d392249?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation>

 

## 6. 线程同步的方式和机制

**临界区**（Critical Section）、**互斥对象**（Mutex）：主要用于互斥控制；都具有拥有权的控制方法，只有拥有该对象的线程才能执行任务，所以拥有，执行完任务后一定要释放该对象。

**信号量**（Semaphore）、**事件对象**（Event）：事件对象是以通知的方式进行控制，主要用于同步控制！

1、**临界区**：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。它并不是核心对象，不是属于操作系统维护的，而是属于进程维护的。

总结下关键段：

1）关键段共初始化化、销毁、进入和离开关键区域四个函数。

2）关键段可以解决线程的互斥问题，但因为具有“线程所有权”，所以无法解决同步问题。

3）推荐关键段与旋转锁配合使用。

2、**互斥对象**：互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。

总结下互斥量Mutex：

1）互斥量是内核对象，它与关键段都有“线程所有权”所以不能用于线程的同步。

2）互斥量能够用于多个进程之间线程互斥问题，并且能完美的解决某进程意外终止所造成的“遗弃”问题。

3、**信号量**：信号量也是内核对象。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。

在用CreateSemaphore()创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号。但是当前可用计数减小到0 时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore（）函数将当前可用资源计数加1。在任何时候当前可用资源计数决不可能大于最大资源计数。

4、**事件对象**：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作

总结下事件Event

1）事件是内核对象，事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。

2）事件可以由SetEvent()来触发，由ResetEvent()来设成未触发。还可以由PulseEvent()来发出一个事件脉冲。

3）事件可以解决线程间同步问题，因此也能解决互斥问题。

 

# 计算机网络

## 1. 当你在浏览器地址栏输入www.google.com，敲下回车之后都发生了什么

1. **应用层：**DNS解析域名为目的IP，通过IP找到服务器路径，客户端向服务器发起HTTP会话，然后通过运输层TCP协议封装数据包，在TCP协议基础上进行传输
2. **运输层：**HTTP会话会被分成报文段，添加源、目的端口；TCP协议进行主要工作
3. **网络层：**为数据包选择路由，IP协议进行主要工作
4. **数据链路层：**相邻结点的可靠传输，ARP协议将IP地址转成MAC地址。数据链路的信道主要有两种模式：**点对点信道**：这种信道使用一对一的点对点通信方式；**广播信道**：这种信道使用一对多的广播通信方式，因此过程比较复杂。

 

**各层的传输单位**：

-   **应用层**：应用层是报文，报文在发送之前会划分为等长的数据段，在每段前面加上一些必要的控制信息后，就构成了一个分组，叫做包。

-   **传输层**：使用TCP的话，单位是报文段，UDP的单位是用户数据报。

-   **网络层**：IP数据报

-   **数据链路层**：帧

-   **物理层**：比特，也就是0和1


## 2. TCP的三次握手，四次关闭

位码即TCP标志位，有6种标示：SYN(synchronous建立联机) 、ACK(acknowledgement 确认)、 PSH(push传送) 、FIN(finish结束) 、RST(reset重置)、 URG(urgent紧急)、Sequence number(顺序号码)、 Acknowledge number(确认号码)

<https://blog.csdn.net/qzcsu/article/details/72861891>

**2.1** **三次握手**

三次握手的**目的**是“**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**”。

TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:

TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，如图所示。

（1）第一次握手：建立连接时，客户端A发送**SYN报文段**（SYN=j）到服务器B，并进入**SYN_SEND状态**，等待服务器B确认。

（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即**SYN+ACK报文段**，此时服务器B进入**SYN_RECV**状态。

（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认**ACK报文段（ACK=k+1）**，此包发送完毕，客户端A和服务器B进入**ESTABLISHED状态**，完成三次握手。

完成三次握手，客户端与服务器开始传送数据。

![](.\images\TCP三次握手.jpg)

**1.2** **四次挥手，关闭连接**

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。

（1）客户端A发送一个**FIN**报文段**，用来关闭客户A到服务器B的数据传送，此时客户端进入**FIN_WAIT_1**状态**。

（2）服务器B收到这个FIN报文段后，它发回一个**ACK报文段**，确认序号为收到的序号加1，此时服务端进入**CLOSE_WAIT状态**。和SYN一样，一个FIN将占用一个序号。当客户端收到此ACK后，客户端进入**FIN_WAIT_2状态**。

（3）服务器B关闭与客户端A的连接，发送一个**FIN报文段**给客户端A，此时服务端进入**LAST_ACK状态**。

（4）客户端A发回**ACK报文段**进行确认，并将确认序号设置为收到序号加1,此时客户端进入**TIME_WAIT状态**。假定ACK丢失，TIME_WAIT状态使TCP客户重传最后的确认报文。在TIME_WAIT状态中所消耗的时间是与具体实现有关的，而典型的值是3秒、1分钟或2分钟。经过等待后，连接就正式关闭，客户端所有资源将被释放。

TCP采用四次挥手关闭连接如图所示。 

**状态转移图：**![](.\images\TCP四次挥手.png)

## 3. TCP,UDP区别

- TCP面向连接，UDP面向非连接即发送数据前不需要建立连接

- TCP提供可靠的服务（数据传输），UDP无法保证

- TCP面向字节流，UDP面向报文

- TCP数据传输慢，UDP数据传输快


**TCP对应的协议：**

1. FTP：定义了文件传输协议，使用21端口。

2. Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。

3. SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。

4. POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。

5. HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。


**UDP对应的协议：**

1. DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。

2. SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。

3. TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。


## 4. TCP协议如何来保证传输的可靠性

1. 应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。(**将数据截断为合理的长度**)

2.  当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。(**超时重发**)

3. 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。(**对于收到的请求，给出确认响应**) (之所以推迟，可能是要对包做**完整校验**)

4. TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。(**校验出包有错，丢弃报文段，不给出响应，TCP发送数据端，超时时会重发数据**)

5. 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。(**对失序数据进行重新排序，然后才交给应用层**)

6. 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。(**对于重复数据，能够丢弃重复数据**)

7. TCP还能提供**流量控制**。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。(**TCP可以进行流量控制，防止较快主机致使较慢主机的缓冲区溢出**)TCP使用的流量控制协议是可变大小的**滑动窗口协议**。


## 5. 流量控制、拥塞控制

**流量控制**以消除发送方使的接收方缓存区溢出的可能性，因此可以说流量控制是一个速度匹配服务（匹配发送方的发送速率与接收方的读取速率）。在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这就是接收窗口rwnd，即调整TCP报文段首部中的**窗口**字段值，来限制发送方向网络注入报文的速率。

**拥塞控制**就是防止过多的数据注入到网络中，这样可以防止网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。

TCP的拥塞控制由4个核心的算法组成：**慢启动**（slow start）、**拥塞避免**（Congestion voidance）、**快重传**（Fast Retransmit）和**快恢复**（Fast Recovery）。![](.\images\拥塞控制.png)

**快重传：**当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。

**快恢复：**当发送端连续收到三个冗余ACK时，就把慢开始门限设置为出现拥塞发送方cwnd的一半。与慢开始不同的是它把cwnd的值设置为慢开始门限改变后的数值 ，然后开始执行拥塞避免算法，使拥塞窗口缓慢线性增大。

慢开始、拥塞避免算法、快重传和快恢复几种算法应该是同时应用在拥塞控制机制中的，当发送方检测到超时的时候就采用慢开始和拥塞避免，当发送方接收到冗余ACK的时候就采用快重传和快恢复。

## 6. 滑动窗口、拥塞窗口

窗口分为**滑动窗口**和**拥塞窗口**。

**滑动窗口**是接受数据端使用的窗口大小，用来告知发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。

那么对于数据的发送端就是**拥塞窗口**了，拥塞窗口不代表缓存，拥塞窗口指某一源端数据流在一个RTT内可以最多发送的数据包数。

 

## 7. HTTP各个版本的区别

HTTP（Hypertext transfer protocol）超文本传输协议，是一个应用层的通信协议。

**HTTP协议版本介绍：**

**HTTP/0.9:**只接受GET一种请求方法，没有在通信中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。

**HTTP/1.0:**第一个在通信中指定的版本号，至今被广泛采用，特别是在代理服务器中。

**HTTP/1.1:**当前版本号，**持久连接被默认采用**，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。

**HTTP/2.0:**正在开发中······

 

**HTTP/1.1与HTTP/1.0的区别：**

**①** **persistent connection**（持久连接）

HTTP/1.0中，每对请求/ 响应都使用一个新的连接。

HTTP/1.1则支持持久连接（默认）。

**②** **Host域**

HTTP/1.1在请求消息头多一个Host域；HTTP/1.0则没有这个域，建立TCP连接的时候已经指定了IP地址，而且默认一个IP地址只对应一个主机名，IP地址上只有一个host。

**③** **带宽优化**

HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限），此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。注意，HTTP/1.0的客户端不支持100响应码。

节省带宽资源的一个非常有效的做法就是压缩要传送的数据。Content-Encoding是对消息进行端到端（end-to-end）的编码，它可能是资源在服务器上保存的固有格式（如jpeg图片格式）；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式。而Transfer-Encoding是逐段式（hop-by-hop）的编码，如Chunked编码。在请求消息中加入TE头域用来告诉服务器能够接收的transfer-coding方式。

**④** **请求方法和状态码**

HTTP1.1增加了OPTIONS, PUT, DELETE, TRACE, CONNECT这些Request方法

HTTP/1.0中只定义了16个状态响应码，对错误或警告的提示不够具体。HTTP/1.1引入了一个Warning头域，增加对错误或警告信息的描述。

在HTTP/1.1中新增了24个状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

**⑤** **内容协商**

为了满足互联网使用不同母语和字符集的用户，一些网络资源有不同的语言版本（如中文版、英文版）。HTTP/1.0定义了内容协商（content negotiation）的概念，也就是说客户端可以告诉服务器自己可以接收以何种语言（或字符集）表示的资源。例如如果服务器不能明确 客户端需要何种类型的资源，会返回300（Multiple Choices），并包含一个列表，用来声明该资源的不同可用版本，然后客户端在请求消息中包含Accept-Language和Accept- Charset头域指定需要的版本。

**⑥** **状态码**

100～199：信息状态码，表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程

100（continue）**继续发送**

200～299：**成功状态码**，表示成功接收请求并已完成整个处理过程，常用200（OK）成功接收

300～399：**重定向状态码**，例如，请求的资源已经移动一个新地址，常用302、307和304

400～499：**客户端的请求有错误**，常用404（Not Found），403（Fobidden）

500～599：**服务器端出现错误**，常用 500

## 8. HTTP请求和响应的全过程

## 9. HTTP有没有状态？

无状态，怎么解决HTTP无状态，怎么解决HTTP无状态其实就是怎么进行**会话跟踪**，有四种方法：**URL重写**、**隐藏表单域**、**Cookie**、**Session**。

## 10. HTTP常见响应码：200、301、302、404、500

**一、1开头**

**1xx(临时响应)**表示临时响应并需要请求者继续执行操作的状态代码。**代码 说明

**二、2开头**

**2xx (成功)**表示成功处理了请求的状态代码。

**200 (成功)** 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。

**三、3开头**

3xx (重定向) 表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。

**301(永久移动)** 请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。

**302 (临时移动)** 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

**四、4开头**

4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。

- **403 (禁止)** 服务器拒绝请求。资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致，比如IIS或者apache设置了访问权限不当。或者可能是客户端IP被列入黑名单等。
- **404 (未找到)** 服务器找不到请求的网页。

- **405 (方法禁用)** 禁用请求中指定的方法。

**五、5开头**

5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

- 500 (服务器内部错误) 服务器遇到错误，无法完成请求。
- 501 服务器不具备完成请求的功能 
- **502 错误网关、无效网关**
- 503 服务器不可用（超载或者停机维护，暂停的状态） 
- **504 网关超时**
- 505 http版本不受支持（请求使用的http协议版本服务器不支持）

## 11. get和post的区别

-  GET在浏览器回退时是无害的，而POST会再次提交请求。

-  GET产生的URL地址可以被Bookmark，而POST不可以。

-  GET请求会被浏览器主动cache，而POST不会，除非手动设置。

-  GET请求只能进行url编码，而POST支持多种编码方式。

-  GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

-  GET请求在URL中传送的参数是有长度限制的，而POST没有。

-  对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

-  GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

-  GET参数通过URL传递，POST放在Request body中。


## 12. forward和redirect的区别

**转发是服务器行为，重定向是客户端行为**。

**转发（Forword）** 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher 可以通过HttpServletRequest 的 getRequestDispatcher()方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。

request.getRequestDispatcher("login_success.jsp").forward(request, response);

**重定向（Redirect）是利用服务器返回的状态吗来实现的**。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。

1. 从地址栏显示来说: forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

2. 从数据共享来说: forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.
3. 从运用地方来说: forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等
4. 从效率来说: forward:高. redirect:低.

## 13. osi七层模型

  ![](.\images\osi七层模型.gif)

## 14. TCP/IP四层模型及原理

  

## 15. 粘包、丢包

**粘包出现的原因**：在流传输中会出现（如TCP），UDP不会出现粘包（数据报传输）

- 发送端需要等缓冲区满才发送出去，造成粘包（nalge算法也可能造成粘包现象）

- 接收方不及时接收缓冲区的包，造成多个包接收




**粘包解决的办法**

- 一是对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；

- 二是对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；

- 三是由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包


还有的笨方法是在两次send函数之间添加 sleep函数，显然会降低数据传输效率

以上提到的三种措施，都有其不足之处。

- 第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。

- 第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。

- 第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。 


**丢包的主要原因**

1. 接收端处理时间过长导致丢包：调用recv方法接收端收到数据后，处理数据花了一些时间，处理完后再次调用recv方法，在这二次调用间隔里，发过来的包可能丢失。对于这种情况可以修改接收端，将包接收后存入一个缓冲区，然后迅速返回继续recv.

2. 发送的包较大，超过接受者缓存导致丢包：包超过mtu size数倍，几个大的udp包可能会超过接收者的缓冲，导致丢包

3. 发送的包频率太快：虽然每个包的大小都小于mtu size 但是频率太快

**解决方案**

1. 模拟tcp三次握手协议，通过使用Timer定时器监视发送请求后接受数据的时间，如果一段时间内没有接受到数据包则判定丢包，并重新发送本次请求

2. 换TCP

## 16. 编写socket套接字的流程

**服务器端程序的编写步骤：**

第一步：调用socket()函数创建一个用于通信的套接字。

第二步：给已经创建的套接字绑定一个端口号，这一般通过设置网络套接口地址和调用bind()函数来实现。

第三步：调用listen()函数使套接字成为一个监听套接字。

第四步：调用accept()函数来接受客户端的连接，这是就可以和客户端通信了。

第五步：处理客户端的连接请求。

第六步：终止连接。

**客户端程序编写步骤：**

第一步：调用socket()函数创建一个用于通信的套接字。

第二步：通过设置套接字地址结构，说明客户端与之通信的服务器的IP地址和端口号。

第三步：调用connect()函数来建立与服务器的连接。

第四步：调用读写函数发送或者接收数据。

第五步：终止连接。

 

## 17. 子网划分

## 18. IPV4和IPV6

## 19. HTTPS和HTTP/2

## 20. Hibernate的session和http的session的区别

## 21. ServerSocketChannel和SocketChannel与ServerSoket和Socket的区别

**1.ServerSocket类**

创建一个ServerSocket类，同时在运行该语句的计算机的指定端口处建立一个监听服务，如：

ServerSocket MyListener=new ServerSocket(600)；

这里指定提供监听服务的端口是600，一台计算机可以同时提供多个服务，这些不同的服务之间通过端口号来区别，不同的端口号上提供不同的服务。为了随时监听可能的Client请求，执行如下的语句：

Socket LinkSocket=MyListener.accept()；

该语句调用了ServerSocket对象的accept()方法，这个方法的执行将使Server端的程序处于等待状态，程序将一直阻塞直到捕捉到一个来自Client端的请求，并返回一个用于与该Client通信的Socket对象Link-Socket。此后Server程序只要向这个Socket对象读写数据，就可以实现向远端的Client读写数据。结束监听时，关闭ServerSocket对象：Mylistener.close()；

**2.Socket类**

当Client程序需要从Server端获取信息及其他服务时，应创建一个Socket对象：

Socket mySocket=new Socket(“ServerComputerName”，600)；

Socket类的构造函数有两个参数，第一个参数是欲连接到的Server计算机的主机地址，第二个参数是该Server机上提供服务的端口号。

Socket对象建立成功之后，就可以在Client和Server之间建立一个连接，并通过这个连接在两个端点之间传递数据。利用Socket类的方法getOutputStream()和getInputStream()分别获得向Socket读写数据的输入／输出流，最后将从Server端读取的数据重新返还到Server端。

当Server和Client端的通信结束时，可以调用Socket类的close()方法关闭Socket，拆除连接。

**ServerSocket** **一般仅用于设置端口号和监听，真正进行通信的是服务器端的Socket与客户端的Socket，在ServerSocket进行accept之后，就将主动权转让了。**

 

Socket、SocketChannel二者的实质都是一样的，都是为了实现客户端与服务器端的连接而存在的，但是在使用上，却有很大的区别。具体如下：

**所属包不同：**Socket在java.net包中，而SocketChannel在java.nio包中。

**异步方式不同：**从包的不同，我们大体可以推断出他们主要的区别：Socket是阻塞连接（当然我们可以自己实现非阻塞），SocketChannel可以设置非阻塞连接。 使用ServerSocket、Socket类时，服务端Socket往往要为每一个客户端Socket分配一个线程，而每一个线程都有可能处于长时间的阻塞状态中。过多的线程也会影响服务器的性能（可以使用线程池优化，具体看这里：如何编写多线程Socket程序）。而使用SocketChannel、ServerSocketChannel类可以非阻塞通信，这样使得服务器端只需要一个线程就能处理所有客户端socket的请求。

**性能不同：**一般来说使用SocketChannel会有更好的性能。其实，Socket实际应该比SocketChannel更高效，不过由于使用者设计等原因，效率反而比直接使用SocketChannel低。

**使用方式不同：**Socket、ServerSocket类可以传入不同参数直接实例化对象并绑定ip和端口。

# 数据库

## 1. 范式

范式：英文名称是 Normal Form，它是英国人 E.F.Codd（关系数据库的老祖宗）在上个世纪70年代提出关系数据库模型后总结出来的，范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。目前有迹可寻的共有8种范式，依次是：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。通常所用到的只是前三个范式，即：**第一范式（1NF）**，**第二范式（2NF）**，**第三范式（3NF）**。

设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。

目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。

下面就简单介绍下这三个范式。

1) **第一范式（1NF**）

强调的是列的**原子性**，即列不能够再分成其他几列。 

考虑这样一个表：【联系人】（姓名，性别，电话） 

如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）。1NF 很好辨别，但是 2NF 和 3NF 就容易搞混淆。 

说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。

2) **第二范式（2NF**）

首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 

考虑一个订单明细表：【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）。 

因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是（OrderID，ProductID）。显而易见 Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。 

可以把【OrderDetail】表拆分为【OrderDetail】（OrderID，ProductID，Discount，Quantity）和【Product】（ProductID，UnitPrice，ProductName）来消除原订单表中UnitPrice，ProductName多次重复的情况。

第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。

3) **第三范式（3NF）**

在1NF基础上，任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖。

第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。

首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 考虑一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。 

其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。 

通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。 

第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：**非主键列是否完全依赖于主键，还是依赖于主键的一部分**；3NF：**非主键列是直接依赖于主键，还是直接依赖于非主键列**。

 

## 2. 数据库事务和隔离级别

如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：

**⑴** **原子性（Atomicity）**

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

**⑵** **一致性（Consistency）**

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

**⑶** **隔离性（Isolation）**

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。

**⑷** **持久性（Durability）**

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的**隔离性**，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：

**1，脏读**

脏读是指在一个事务处理过程里读取了另一个**未提交的事务**中的数据。

当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。

1.Mary的原工资为1000, 财务人员将Mary的工资改为了8000(但未提交事务) ；

2.Mary读取自己的工资 ,发现自己的工资变为了8000，欢天喜地！

3.而财务发现操作有误，回滚了事务,Mary的工资又变为了1000。

像这样,Mary记取的工资数8000是一个脏数据。

**2，不可重复读**

不可重复读是指在对于数据库中的某个数据，**一个事务范围内**多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。

不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……

**3，虚读(幻读)**

幻读是**事务非独立执行**时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

现在来看看MySQL数据库为我们提供的四种隔离级别：

1. Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

2. Read committed (读已提交)：可避免脏读的发生。

3. Repeatable read (可重复读)：可避免脏读、不可重复读的发生。

4. Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。




## 3. 为什么需要锁，锁定分类，锁粒度

**为什么需要锁：**

数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。

**锁的分类：**

**共享（S）锁**：多个事务可封锁一个共享页；任何事务都不能修改该页；通常是该页被读取完毕，S锁立即被释放。 

**排它（X）锁**：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。 

**更新（U）锁**：更新锁在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个事务申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这时，这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。



**锁的粒度**：

1) **行级锁定（row-level）**

行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

缺陷：由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。

2) **表级锁定（table-level）**

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

缺陷：锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣。

3) **页级锁定（page-level）**：（MySQL特有）

页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

缺陷：页级锁定和行级锁定一样，会发生死锁。

## 4. 乐观锁，悲观锁的概念及实现方式

**悲观锁（Pessimistic Lock）**，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。

**乐观锁（Optimistic Lock**）**，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于**读多写少**的应用场景，这样可以提高吞吐量。

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

乐观锁一般来说有以下2种方式：

- 使用**数据版本（Version）**记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

- 使用**时间戳（timestamp）**。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。


Java JUC中的atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。

**乐观锁与悲观锁的区别**

乐观锁的思路一般是表中增加版本字段，更新时where语句中增加版本的判断，算是一种CAS（Compare And Swep）操作，商品库存场景中number起到了版本控制（相当于version）的作用（ AND number=#{number}）。

悲观锁之所以是悲观，在于他认为本次操作会发生并发冲突，所以一开始就对商品加上锁（SELECT ... FOR UPDATE），然后就可以安心的做判断和更新，因为这时候不会有别人更新这条商品库存。

## 5. 分页如何实现（Oracle，MySql）

一般对MySQL数据库分页，我们都会使用到其自带的limit函数。

语法：select * from users limit 10,5;（limit offset,rowsmys）

## 6. Mysql引擎

InnoDB和MyIsam

[参考链接](https://blog.csdn.net/Jack__Frost/article/details/72904318)

MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：**不支持事务处理（**transaction**）**。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。

InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。

MyISAM与InnoDB的区别是什么？

**1、存储结构**

MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。

InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。

**2、存储空间**

MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。

InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

**3、可移植性、备份及恢复**

MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。

InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。

**4、事务支持**

MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。

InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

**5、AUTO_INCREMENT**

MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。

InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。

**6、表锁差异**

MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。

InnoDB：**支持事务和行级锁，是innodb的最大特色**。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。

**7、全文索引**

MyISAM：支持 FULLTEXT类型的全文索引

InnoDB：不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。

**8、表主键**

MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。

InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值的数据列。

**9、表的具体行数**

MyISAM：保存有表的总行数，如果select count() from table;会直接取出出该值。

InnoDB：没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。

**10、CURD操作**

MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。

InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。

**11、外键**

MyISAM：不支持

InnoDB：支持

通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。 

**存储引擎选择的基本原则：**

**采用MyISAM引擎：**

- R/W > 100:1 且update相对较少

- 并发不高

- 表数据量小

- 硬件资源有限


**采用InnoDB引擎**

- R/W比较小，频繁更新大字段

- 表数据量超过1000万，并发高

- 安全性和可用性要求高


**采用Memory引擎**

- 有足够的内存

- 对数据一致性要求不高，如在线人数和session等应用

- 需要定期归档数据


## 7. MYSQL语句优化

## 8. 索引以及索引的实现(B+树介绍、和B树、R树区别)

### 索引

> 按照**存储类型**分为：B树、B+树、Hash
> 按照**索引类别**分为：聚集索引、非聚集索引

- **聚集索引**： 按照每张表的主键构造一棵B+树，同时**叶子节点中存放的即为整张表的行记录数据**，也将聚集索引的叶子节点称为数据页。每张表只能拥有**一个**聚集索引。在多数情况下，查询优化器倾向于采用聚集索引，因为聚集索引能够在B+树索引的叶子节点上直接找到数据。**注意**：聚集索引并不是在物理存储上是连续的，其只是在逻辑上连续。这有两点：1、数据页是按照**主键的顺序**并通过双向链表链接的，因此物理存储上可以不按主键顺序存储。2、数据页中的记录也是通过**双向链表**进行维护的，物理存储上同样可以不按主键顺序存储。
- **辅助索引**(也称**非聚集索引**)：叶子节点并不包含行记录的全部数据。
- **联合索引**：联合索引是指同时对表上的多个列进行索引。
- **覆盖索引**：从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。
- **全文检索**：全文检索是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。它可以根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。

​    [参考链接1]( https://zhuanlan.zhihu.com/p/23624390)

​    [参考链接2](https://zhuanlan.zhihu.com/p/27700617)

## 9. 从一张大表读取数据，如何解决性能问题

第一**优化SQL语句和索引**；

第二加**缓存**，memcached，redis；

第三以上都做了后，还是慢，就做主从复制或主主复制，**读写分离**，可以在应用层做，效率高，也可以用三方工具，第三方工具推荐360的atlas,其它的要么效率不高，要么没人维护；

第四如果以上都做了还是慢，不要想着去做切分，**mysql自带分区表**，先试试这个，对你的应用是透明的，无需更改代码，但是sql语句是需要针对分区表做优化的，sql条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，另外分区表还有一些坑，在这里就不多说了；

第五如果以上都做了，那就先做**垂直拆分**，其实就是根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；

第六才是**水平切分**，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key，为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；

--------
### 读写分离
**1. what 读写分离**
读写分离，基本的原理是让**主数据库处理事务性增、改、删操作**（INSERT、UPDATE、DELETE），而**从数据库处理SELECT查询**操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。

**2. why 那么为什么要读写分离呢？** 
因为数据库的“写”（写10000条数据到oracle可能要3分钟）操作是比较耗时的。 
但是数据库的“读”（从oracle读10000条数据可能只要5秒钟）。 
所以读写分离，解决的是，**数据库的写入，影响了查询的效率**。

**3. when 什么时候要读写分离？**
数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库**主从同步**。可以减少数据库压力，提高性能。当然，数据库也有其它优化方案。memcache 或是 表折分，或是搜索引擎。都是解决方法。

**4. 主从复制与读写分离**
在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。因此，通过**主从复制**的方式来同步数据，再通过**读写分离**来提升数据库的并发负载能力。

![](.\images\mysql主从复制.png)

**4.1. MySQL支持的复制类型**

1. **基于语句的复制**。在服务器上执行sql语句，在从服务器上执行同样的语句，mysql**默认采用基于语句的复制，执行效率高**。
   **存在的问题**：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同的用户。

2. **基于于行的复制**。把改变的内容复制过去，而不是把命令在从服务器上执行一遍。
   **存在的问题**：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。

3. **混合类型的复制**。默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。

   以上两种方式都是通过**在主库上记录二进制日志，在备库重放日志的方式来实现异步的数据复制**。这意味着，同一时间点上备库中的数据可能与主库不一致。复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但出于备份或及时从崩溃中恢复的目的，这点开销是必要的。

**如何复制**

1. 在主库上把数据更改记录到**二进制日志（Binary Log）**中（这些记录被称为二进制日志事件）

2. 备库将主库上的日志复制到自己的**中继日志（Relay Log）** 中。

3. 备库读取中继日志中的事件，将其重放到备库数据之上。
    ![](.\images\mysql主从复制2.png)下面

  

**主从复制常见问题**

1. 从库数据比主库数据慢，有**延时**

2. 如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了

  **解决方案：**一个是**半同步复制**，用来解决主库数据丢失问题；一个是**并行复制**，用来解决主从同步延时问题。

  **半同步复制**，也叫 `semi-sync` 复制，指的就是主库写入 binlog 日志之后，就会将**强制**此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到**至少一个从库**的 ack 之后才会认为写操作完成了。

  **并行复制**，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后**并行重放不同库的日志**，这是库级别的并行。

  一般来说，如果主从延迟较为严重，有以下解决方案：

  - 分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。
  - 打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。
  - 重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。
  - 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询**设置直连主库**。**不推荐**这种方法，你要是这么搞，读写分离的意义就丧失了。

  

3. 